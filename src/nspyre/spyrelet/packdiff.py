"""
Testing for future spyrelet data acquisition system
1. variables that will contain experimental data are tagged with self.watch(var)
2. on each call to self.progress(), the watched vars are pickled and pushed to a queue
3. the pickle server runs in a separate thread, and pops pickles off the queue
4. each pickle is diff'ed with the previous pickle
5. the diff is sent over the network to any remote processes interested in consuming the data
6. the original objects are reconstructed in real-time from the diffs

Author: Jacob Feder
Date: 11/17/2020
"""
###########################
# imports
###########################

import pickle
import difflib
import logging

###########################
# classes / functions
###########################

def hex_str(byte_arr):
    return ''.join(format(x, ' 02x') for x in byte_arr)

class PackDiffServer():
    def __init__(self, watched):
        # this stores the object that is being watched
        self.watched_obj = watched
        # the result of the most recent serializing operation of watched_obj, 
        # which will be used to diff against
        self.last_pack = self.packed()

    def packed(self):
        """Serialize the object"""
        logging.debug('packing: {}'.format(self.watched_obj))
        return pickle.dumps(self.watched_obj)

    def diff(self):
        """Serialize the watched_obj, then generate a set of operations that 
        will convert the serialized data from the last diff() call into the
        current serialized version of watched_obj"""
        
        # current packed version of the watched object
        curr_pack = self.packed()
        logging.debug('last_pack:{}'.format(hex_str(self.last_pack)))
        logging.debug('curr_pack:{}'.format(hex_str(curr_pack)))

        # array of differences between the last_pack and curr_pack
        diffs = []
        # when bytes are deleted or inserted, the byte indices between the last 
        # and current pack become offset - this variable keeps track of that offset 
        # so that the diffs array contains indices relevant to the object at that moment
        offset = 0
        # use difflib's algorithm to generate a set of simple operations that turn
        # last_pack into curr_pack - see difflib docs on get_opcodes()
        matcher = difflib.SequenceMatcher(None, self.last_pack, curr_pack)
        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            i1 += offset
            i2 += offset
            if tag == 'replace' or tag == 'insert':
                # replace indicies i1:i2 in the self.last_pack with j1:j2 of curr_pack
                diffs.append( (i1, i2, curr_pack[j1:j2]) )
                offset = offset + ((j2 - j1) - (i2 - i1))
            elif tag == 'delete':
                # delete i1:i2 of last_pack
                diffs.append( (i1, i2, b'') )
                offset = offset - (i2 - i1)

        self.last_pack = curr_pack

        return diffs

class PackDiffClient():
    def __init__(self, initial_pack):
        # stores the most recent packed version of the object
        self.pack = initial_pack

    def unpacked(self):
        """Deserialize the object"""
        unpacked_obj = pickle.loads(self.pack)
        logging.debug('unpacked: {}'.format(unpacked_obj))
        return unpacked_obj

    def update(self, diffs):
        """Take an array of diffs generated by the PackDiffServer and apply 
        them to the packed object, then return the new, updated object"""
        logging.debug('diffs:{}'.format( [(d[0], d[1], hex_str(d[2])) for d in diffs] ))
        for d in diffs:
            i1 = d[0]
            i2 = d[1]
            change_str = d[2]
            self.pack = self.pack[:i1] + change_str + self.pack[i2:]
        logging.debug('new_pack:{}'.format(hex_str(self.pack)))
        return self.unpacked()

def test_packdiff():
    import random
    import numpy as np

    random.seed()

    watched_var = {50:[1, 2, 3], 'a':'test', 60:np.array([3.4, 6.0])}
    for i in range(100):
        watched_var[i] = random.randint(0, 100)

    pds = PackDiffServer(watched_var)
    pdc = PackDiffClient(pds.packed())

    for i in range(10000):
        # pick a number of changes to make
        nchanges = random.randint(1, 10)
        for c in range(nchanges):
            # pick an operation to perform on that index (delete or replace/add)
            op = random.randint(0, 1)
            if op:
                # pick a random key
                idx = random.randint(0, 100)
                # replace or add with a new random value
                watched_var[idx] = random.randint(0, 100)
            else:
                if len(watched_var):
                    # pick a random (existing) key
                    idx_key = list(watched_var.keys())[random.randint(0, len(watched_var) - 1)]
                    # delete that key
                    del watched_var[idx_key]

        # run the diff algorithm and generate a diffs list
        diffs = pds.diff()

        # use the diffs to reconstruct the watched object
        remote_var = pdc.update(diffs)

        assert watched_var == remote_var

if __name__ == '__main__':
    from nspyre.misc.logging import nspyre_init_logger
    nspyre_init_logger(logging.DEBUG)
    test_packdiff()
